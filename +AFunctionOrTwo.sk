# @desc:			Creates  a string based on the entity's UUIDLeast and UUIDMost tags. Should be unique to each entity.
# @params: 	e: the entity to get the UUID string for
# @returns:		The string of the combined UUIDLeast and UUIDMost tags
function getUUID(e: entity) :: text:
	return "%tag ""UUIDLeast"" of nbt of {_e}%%tag ""UUIDMost"" of nbt of {_e}%"



# @desc:			Creates a string representing the components of a location for use in console commands.
# @params:	loc: The location to create a string for.
#						xOff: The offset to apply to loc's x coordinate. Optional. Defaults to 0.
#						yOff: The offset to apply to loc's y coordinate. Optional. Defaults to 0.
#						zOff: The offset to apply to loc's z coordinate. Optional. Defaults to 0.
# @returns:		The string representing the three components of the location with the offset applied.
function locString(loc: location, xOff: number = 0, yOff: number = 0, zOff: number = 0) :: string:
	return "%{_loc}'s x location + {_xOff}% %{_loc}'s y location + {_yOff}% %{_loc}'s z location + {_zOff}%"



# @desc:			Plays the provided sound name at a location.
# @params:	p: The player to play the sound from (vanilla commands need to execute relative to a player.)
#						sound: The name of the sound file to be played.
#						category: The category which the sound should draw its volume from.
#						loc: The location the sound should be played at.
#						vol: The volume the sound should be played at, should be between 0 and 2. Optional. Defaults to 1.
#						pitch: The pitch the sound should be played at, should be between 0 and 2. Optional. Defaults to 1.
#						selector: A command selector text of who should be able to hear the sound. Optional. Defaults to all players within 100 blocks of the play location.
function playsound(sound: text, category: text, loc: location, vol: number = 1, pitch: number = 1, selector: text = "@a[r=100]"):
	loop players in world of {_loc}:
		distance between {_loc} and loop-player <= 100
		execute console command "execute %loop-player% ~ ~ ~ /playsound %{_sound}% %{_category}% %{_selector}% %locString({_loc})% %{_vol}% %{_pitch}%"
		stop loop



# @desc:			Spawns particles at the provided location.
# @params:	p: The player to play the sound from (vanilla commands need to execute relative to a player.)
#						particle: The name of the particle that should be spawned.
#						loc: The location the particles should be spawned at.
#						count: The number of particles to spawn. Optional. Defaults to 25.
#						xd: The randomization to apply to the x spawn location. Optional. Defaults to 0.
#						yd: The randomization to apply to the y spawn location. Optional. Defaults to 0.
#						zd: The randomization to apply to the z spawn location. Optional. Defaults to 0.
#						speed: The speed the particle should move at. Optional. Defaults to 0.05.
#						mode: The mode of the particle, either "normal" or "force", which forces clients with low particle settings to render it. Optional. Defaults to "normal".
#						selector: A command selector text of who should be able to see the particles. Optional. Defaults to all players.
#						params: The parameters for the particle, only relevent for blockdust, blockcrack, and iconcrack, where it represents the block/icon ID and data value, respectively. Optional. Defaults to "0 0".
function particle(particle: text, loc: location, count: integer = 25, xd: number = 0, yd: number = 0, zd: number = 0, speed: number = 0.05, mode: text = "normal", selector: text = "@a", params: text = "0 0"):
	loop players in {_loc}'s world:
		distance between {_loc} and loop-player <= 100
		execute console command "execute %loop-player% ~ ~ ~ /particle %{_particle}% %locString({_loc})% %{_xd}% %{_yd}% %{_zd}% %{_speed}% %{_count}% %{_mode}% %{_selector}% %{_params}%"
		stop loop



# @desc:			Drops the provided item at the provided location with a randomized offset. Can't be picked up and despawns after itemDuration ticks.
#	@params:	loc: The location to drop the item at.
#						item: The item type to drop. Provide it as a Skript itemstack.
# 						randomOffset: The randomization to apply to the spawn location on each axis. Optional. Defaults to 1.5.
#						itemDuration: How many ticks the items should exist for before despawning. Optional. Defaults to 20 (one second).
function decorativeItemDrop(loc: location, item: item, randomOffset: number = 1.5, itemDuration: integer = 20):
	add random number between -1*{_randomOffset} and {_randomOffset} to {_loc}'s x location
	add random number between -1*{_randomOffset} and {_randomOffset} to {_loc}'s y location
	add random number between -1*{_randomOffset} and {_randomOffset} to {_loc}'s z location
	drop {_item} at {_loc}
	loop dropped items in radius 2 of {_loc}'s location:
		items within entity loop-entity is {_item}
		add "{PickupDelay:32767,Age:%6000 - {_itemDuration}%}" to nbt of loop-entity



# @desc:			Tells you whether or not a world is a normal SSS survival world (one of the main worlds or a resource world).
# @params:	w: The world to check agains.
# @returns:		True if the world is a normal survival world, false if otherwise.
function isASurvivalWorld(w: world) :: boolean:
	if "%{_w}%" contains "world" or "resource":
		return true
	else:
		return false



# @desc:			Returns a version of the provided number clamped between min and max.
# @params:	n: The number to clamp.
# 						min: The minimum to return (if n is less than min, it'll return min).
# 						max: The maximum to return (if n is greater than min, it'll return max).
# @returns:		The clamped value of n.
function clamp(n: number, min: number, max: number) :: number:
	if {_n} < {_min}:
		set {_n} to {_min}
	else if {_n} > {_max}:
		set {_n} to {_max}
		
	return {_n}



# @desc:			Executes `wait 0 ticks` to simulate nothing happening, as Skript has no effect for loops like `continue`.
# @params:	n: Completely useless and unused, but Skript functions require at least one parameter.
function doNothing(n: number = 0):
	wait 0 ticks



# @desc:			Spawns particles and plays a sound effect at a location, used for custom scripted bonemeal effects.
# @params:	p: The player to execute the effects from (vanilla commands need to execute relative to a player.)
#						loc: The location to play the effect at.
function bonemealEffect(loc: location):
	particle("happyVillager", {_loc}, 10, 0.15, 0.15, 0.15, 0)
	playsound("block.enchantment_table.use", "block", {_loc}, 0.125, 2)



# @desc:			Returns the number of free slots in the player's inventory.
# @params:	p: The player to check for the number of free spaces.
#						countArmorSlots: Whether or not open armor slots should count as free slots. Optional. Defaults to false.
# @returns:		The number of free slots in the player's inventory.
function getFreeSpace(p: player, countArmorSlots: boolean = false) :: number:
	set {_space} to amount of air in {_p}'s inventory

	if {_countArmorSlots} is false:		
		if "%{_p}'s helmet%" is "<none>":
			subtract 1 from {_space}
		if "%{_p}'s chestplate%" is "<none>":
			subtract 1 from {_space}
		if "%{_p}'s leggings%" is "<none>":
			subtract 1 from {_space}
		if "%{_p}'s boots%" is "<none>":
			subtract 1 from {_space}
		
	if "%{_p}'s offhand%" is "0 air":
		subtract 1 from {_space}
	
	return {_space}



# @desc:			Sends the provided message to all players with the specific permission.
# @params:	msg: The message to send.
#						perm: The permission which should be required.
function sendWithPerms(msg: text, perm: text):
	loop players:
		if loop-player has permission "%{_perm}%":
			send "%{_msg}%" to loop-player



# @desc:			Makes the given entity look at a specific location.
# @params:	e: The entity that will do the looking.
#						loc: The location which the entity should look towards.
function makeLook(e: living entity, loc: location):
	set {_xD} to {_loc}'s x location - {_e}'s x location
	set {_yD} to {_loc}'s y location - {_e}'s y location
	set {_zD} to {_loc}'s z location - {_e}'s z location
	set {_yaw} to atan2({_xD}, {_zD}) - 90
	set {_newLoc} to {_e}'s location
	set yaw of {_newLoc} to {_yaw}
	
	set {_adj2} to ({_xD}*{_xD}) + ({_zD}*{_zD})
	set {_parallel} to sqrt({_adj2})
	set {_pitch} to atan2({_yD}, {_parallel}) - 90
	set pitch of {_newLoc} to {_pitch}
	
	teleport {_e} to {_newLoc}
	add "{Rotation:[%{_yaw}%f, %{_pitch}%f]}" to nbt of {_e}



# @desc:			Takes a number in seconds and returns it as a presentable time string.
#						e.g. An arg of 123 would return "2 minutes and 3 seconds"
# @params:	seconds: The number of seconds to parsed into the timespan
# @returns:		The presentable time as a string.
function secondsToTimespan(seconds: number) :: text:
	set {_daysAndHours} to "%{_seconds} - mod({_seconds}, 3600)% seconds" parsed as a timespan
	set {_minutesAndSeconds} to "%mod({_seconds}, 3600)% seconds" parsed as a timespan
	set {_daysAndHours} to "%{_daysAndHours}%"
	replace all " and " in {_daysAndHours} with ", "
	
	if "%{_daysAndHours}%" is "0 seconds":
		return "%{_minutesAndSeconds}%"
	else:
		return "%{_daysAndHours}%, %{_minutesAndSeconds}%"



# @desc:			Sends the client a cooldown for an item type, displays for them like the ender pearl CD or shield disable.
#						Note that this doesn't stop them from actually using the item, but it stops the arm swing use-attempt animation.
#	@params:	p: player to send the cooldown to
#						i: the item type to disable (e.g. "slimeball", not "player's tool")
#						duration: how many ticks to disable the item for
function setCooldown(p: player, itemType: item, duration: integer):
	set {_packet} to new play_server_set_cooldown packet
	set "item" pinfo 0 of {_packet} to {_itemType}
	set int pnum 0 of {_packet} to {_duration}
	send packet {_packet} to {_p}



# @desc:			Tries to give items to a player, and if they can't hold them, it drops it all at their feet instead.
# @params:	p: player to give the item to
#						i: the items to drop
function safelyGive(p: player, i: items):
	loop {_i::*}:
		if {_p} can hold loop-value:
			give loop-value to {_p}
		else:
			drop loop-value at {_p}'s head


# @desc			Plays the arm swing animation on a player.
# @parmas:	p: the player whose arm should swing
#						useOffhand: whether
function playArmSwing(p: player, useOffhand: boolean = false):
	set {_pUUID} to {_p}'s UUID
	{Packet::PlayerID::%{_pUUID}%} is set
	set {_swing} to new play_server_animation packet
	set int pnum 0 of {_swing} to {Packet::PlayerID::%{_pUUID}%}
	if {_useOffhand} is true:
		set int pnum 1 of {_swing} to 3
	loop players in {_p}'s world:
		send packet {_swing} to loop-player


#
function listContains(list: objects, value: object) :: boolean:
	loop {_list::*}:
		if loop-value is {_value}:
			return true
	return false
